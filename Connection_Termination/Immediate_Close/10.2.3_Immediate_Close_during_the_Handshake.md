---
title: "10.2.3 在握手期间立即关闭"
anchor: "10.2.3_Immediate_Close_during_the_Handshake"
weight: 1023
---

When sending a CONNECTION_CLOSE frame, the goal is to ensure that the peer will process the frame. Generally, this means sending the frame in a packet with the highest level of packet protection to avoid the packet being discarded. After the handshake is confirmed (see Section 4.1.2 of [QUIC-TLS]), an endpoint MUST send any CONNECTION_CLOSE frames in a 1-RTT packet. However, prior to confirming the handshake, it is possible that more advanced packet protection keys are not available to the peer, so another CONNECTION_CLOSE frame MAY be sent in a packet that uses a lower packet protection level. More specifically:

发送**连接关闭帧**时，要确保对端会处理这个帧。通常来说，这意味着将这个帧放到具有最高级别的数据包保护的数据包中发送，以避免数据包被丢弃。在握手确认后（详见《[QUIC-TLS]()》的[第4.1.2章]()），终端{{< req_level MUST >}}在1-RTT数据包中发送任何**连接关闭帧**。然而，在确认握手前，更高级的数据包保护密钥有可能在对端那还不可用，所以{{< req_level MAY >}}使用具有较低数据包保护级别的数据包多发送一个**连接关闭帧**。具体来说：

* A client will always know whether the server has Handshake keys (see Section 17.2.2.1), but it is possible that a server does not know whether the client has Handshake keys. Under these circumstances, a server SHOULD send a CONNECTION_CLOSE frame in both Handshake and Initial packets to ensure that at least one of them is processable by the client.

* 客户端总是知道服务器有没有握手密钥（详见[第17.2.2.1章]()），但是服务器不确定客户端有没有握手密钥。在这种条件下，服务器{{< req_level SHOULD >}}用握手数据包和初始数据包各发送一个**连接关闭帧**来确保它们中的至少一个是客户端可以处理的。

* A client that sends a CONNECTION_CLOSE frame in a 0-RTT packet cannot be assured that the server has accepted 0-RTT. Sending a CONNECTION_CLOSE frame in an Initial packet makes it more likely that the server can receive the close signal, even if the application error code might not be received.

* 在0-RTT数据包中发送**连接关闭帧**的客户端不能确信服务器会不会接受0-RTT。用初始数据包发送**连接关闭帧**使得服务器更有可能接收到关闭的信号，哪怕应用错误码可能不会被接收到。

* Prior to confirming the handshake, a peer might be unable to process 1-RTT packets, so an endpoint SHOULD send a CONNECTION_CLOSE frame in both Handshake and 1-RTT packets. A server SHOULD also send a CONNECTION_CLOSE frame in an Initial packet.

* 在确认握手前，对端可能无法处理1-RTT数据包，所以终端{{< req_level SHOULD >}}用握手数据包和1-RTT数据包各发送一个**连接关闭帧**。服务器则{{< req_level SHOULD >}}用初始数据包发送**连接关闭帧**。

Sending a CONNECTION_CLOSE of type 0x1d in an Initial or Handshake packet could expose application state or be used to alter application state. A CONNECTION_CLOSE of type 0x1d MUST be replaced by a CONNECTION_CLOSE of type 0x1c when sending the frame in Initial or Handshake packets. Otherwise, information about the application state might be revealed. Endpoints MUST clear the value of the Reason Phrase field and SHOULD use the APPLICATION_ERROR code when converting to a CONNECTION_CLOSE of type 0x1c.

用初始数据包或握手数据包发送类型为`0x1d`的**连接关闭帧**会暴露应用状态或被用于更改应用状态。用初始数据包或握手数据包发送时，必须将类型为`0x1d`的**连接关闭帧**替换为类型为`0x1c`的**连接关闭帧**。否则，有关应用状态的信息可能被泄露。终端在转换**连接关闭帧**的类型到`0x1c`时{{< req_level MUST >}}清除原因语句字段的值，并且{{< req_level SHOULD >}}使用`APPLICATION_ERROR`（应用错误）代码。

CONNECTION_CLOSE frames sent in multiple packet types can be coalesced into a single UDP datagram; see Section 12.2.

用不同数据包类型发送的**连接关闭帧**可以被合并至单个UDP数据报中；详见[第12.2章]()。

An endpoint can send a CONNECTION_CLOSE frame in an Initial packet. This might be in response to unauthenticated information received in Initial or Handshake packets. Such an immediate close might expose legitimate connections to a denial of service. QUIC does not include defensive measures for on-path attacks during the handshake; see Section 21.2. However, at the cost of reducing feedback about errors for legitimate peers, some forms of denial of service can be made more difficult for an attacker if endpoints discard illegal packets rather than terminating a connection with CONNECTION_CLOSE. For this reason, endpoints MAY discard packets rather than immediately close if errors are detected in packets that lack authentication.

终端可以用初始数据包发送**连接关闭帧**。这时可能是在响应接收自初始数据包或握手数据包的未通过认证的信息。这样的立即关闭行为可能将合法的连接暴露在拒绝服务攻击之下。QUIC对于握手过程中来自路径上设备的攻击并不提供防御措施；详见[第21.2章]()。然而，如果牺牲发向合法对端的关于错误的反馈，并且终端直接丢弃不合法的数据包而不是用**关闭连接帧**终止连接，那么部分形式的拒绝服务攻击对于攻击者来说会变得更难实施。出于这个原因，如果在缺乏认证的数据包中检测出了错误，那么终端{{< req_level MAY >}}丢弃数据包而不是选择立即关闭。

An endpoint that has not established state, such as a server that detects an error in an Initial packet, does not enter the closing state. An endpoint that has no state for the connection does not enter a closing or draining period on sending a CONNECTION_CLOSE frame.

尚未建立状态的终端，例如在初始数据包中检测到错误的服务器，并不会进入关闭状态。在发送**连接关闭帧**时，没有关于连接的状态的终端不会进入关闭或排空状态。
